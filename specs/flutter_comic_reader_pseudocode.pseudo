// @spec_version: 2.0
// @project: Easy-Comic Flutter Reader - Comprehensive Implementation
// @author: Spec-Pseudocode Mode  
// @description: Complete modular pseudocode architecture for Flutter comic reader core functionality
// @reference: flutter_comic_reader_comprehensive_spec.md

// =================================
// 1. CORE ARCHITECTURE - BLoC PATTERN
// =================================

// 1.1 Reader State Definition
CLASS ReaderState:
    IMMUTABLE_PROPERTIES:
        comic: Comic?
        pages: List<ComicPage>
        currentPage: Integer = 0
        totalPages: Integer = 0
        isLoading: Boolean = false
        error: String? = null
        
        // UI State
        isUiVisible: Boolean = true
        zoomScale: Double = 1.0
        
        // Settings
        settings: ReaderSettings
        
        // Data Collections
        bookmarks: List<Bookmark> = []
        thumbnailCache: Map<Integer, String> = {}
        customPageOrder: List<Integer> = []
    
    METHOD copyWith(updates: Map<String, Any>): ReaderState
        RETURN new ReaderState with updated properties
    
    METHOD get isValid(): Boolean
        RETURN comic != null AND pages.isNotEmpty()
    
    METHOD get progress(): Double
        IF totalPages > 0:
            RETURN (currentPage + 1) / totalPages
        RETURN 0.0

// 1.2 Reader Events Definition
ABSTRACT CLASS ReaderEvent

CLASS LoadComicEvent EXTENDS ReaderEvent:
    PROPERTY comicId: String
    PROPERTY initialPage: Integer = 0
    PROPERTY restoreState: Boolean = true

CLASS PageChangedEvent EXTENDS ReaderEvent:
    PROPERTY newPage: Integer
    PROPERTY source: PageChangeSource // USER_SWIPE, PROGRAMMATIC, BOOKMARK_JUMP
    PROPERTY saveProgress: Boolean = true

CLASS ZoomChangedEvent EXTENDS ReaderEvent:
    PROPERTY newScale: Double
    PROPERTY focalPoint: Offset?
    PROPERTY animated: Boolean = true

CLASS ToggleUiVisibilityEvent EXTENDS ReaderEvent:
    PROPERTY forceVisible: Boolean? = null

CLASS UpdateSettingEvent EXTENDS ReaderEvent:
    PROPERTY settingType: SettingType
    PROPERTY value: Any
    PROPERTY persist: Boolean = true

CLASS BookmarkEvent EXTENDS ReaderEvent:
    PROPERTY action: BookmarkAction // ADD, DELETE, UPDATE, JUMP_TO
    PROPERTY bookmarkId: String?
    PROPERTY pageIndex: Integer?
    PROPERTY label: String?

CLASS AutoPageEvent EXTENDS ReaderEvent:
    PROPERTY action: AutoPageAction // START, STOP, PAUSE, RESUME
    PROPERTY interval: Duration?

// 1.3 Reader BLoC Implementation
CLASS ReaderBloc EXTENDS Bloc<ReaderEvent, ReaderState>:
    DEPENDENCIES:
        comicRepository: IComicRepository
        settingsRepository: ISettingsRepository
        bookmarkRepository: IBookmarkRepository
        navigationService: INavigationService
        zoomService: IZoomService
        cacheManager: ICacheManager
        
    PRIVATE_PROPERTIES:
        autoPageTimer: Timer?
        progressSaveTimer: Timer?
        currentComicId: String?
    
    CONSTRUCTOR(dependencies...):
        super(ReaderState.initial())
        REGISTER_EVENT_HANDLERS()
    
    // Event Handlers
    METHOD _onLoadComic(event: LoadComicEvent, emit: Emitter<ReaderState>):
        TRY:
            emit(state.copyWith(isLoading: true, error: null))
            
            // Load comic data
            comic = await comicRepository.getComic(event.comicId)
            pages = await comicRepository.getPages(event.comicId)
            settings = await settingsRepository.getSettings()
            bookmarks = await bookmarkRepository.getBookmarks(event.comicId)
            
            // Apply custom page order if exists
            customOrder = await comicRepository.getCustomPageOrder(event.comicId)
            IF customOrder.isNotEmpty():
                pages = _applyCustomOrder(pages, customOrder)
            
            // Calculate initial page
            initialPage = event.initialPage
            IF event.restoreState:
                savedProgress = await comicRepository.getProgress(event.comicId)
                IF savedProgress != null:
                    initialPage = savedProgress.currentPage
            
            // Preload images
            _startImagePreloading(pages, initialPage)
            
            emit(state.copyWith(
                comic: comic,
                pages: pages,
                currentPage: initialPage,
                totalPages: pages.length,
                settings: settings,
                bookmarks: bookmarks,
                customPageOrder: customOrder,
                isLoading: false
            ))
            
            // Start progress tracking
            _startProgressTracking(event.comicId)
            
        CATCH error:
            emit(state.copyWith(
                isLoading: false,
                error: "Failed to load comic: ${error.message}"
            ))
    
    METHOD _onPageChanged(event: PageChangedEvent, emit: Emitter<ReaderState>):
        IF event.newPage < 0 OR event.newPage >= state.totalPages:
            RETURN // Invalid page number
        
        // Update state
        emit(state.copyWith(currentPage: event.newPage))
        
        // Handle page change effects
        _handlePageChangeEffects(event)
        
        // Save progress if requested
        IF event.saveProgress:
            _scheduleProgressSave()
        
        // Preload adjacent pages
        _preloadAdjacentPages(event.newPage)
        
        // Analytics
        _trackPageView(event.newPage, event.source)
    
    METHOD _onZoomChanged(event: ZoomChangedEvent, emit: Emitter<ReaderState>):
        // Clamp zoom to valid range
        clampedScale = event.newScale.clamp(0.5, 5.0)
        
        // Update zoom service
        zoomService.setZoom(clampedScale, event.focalPoint, event.animated)
        
        emit(state.copyWith(zoomScale: clampedScale))
    
    METHOD _onToggleUiVisibility(event: ToggleUiVisibilityEvent, emit: Emitter<ReaderState>):
        newVisibility = event.forceVisible ?? !state.isUiVisible
        emit(state.copyWith(isUiVisible: newVisibility))
        
        // Auto-hide timer
        IF newVisibility:
            _scheduleUiAutoHide()
    
    METHOD _onUpdateSetting(event: UpdateSettingEvent, emit: Emitter<ReaderState>):
        newSettings = _updateSettingValue(state.settings, event)
        emit(state.copyWith(settings: newSettings))
        
        IF event.persist:
            await settingsRepository.saveSetting(event.settingType, event.value)
        
        // Handle setting-specific effects
        _handleSettingChange(event.settingType, event.value)
    
    METHOD _onBookmarkEvent(event: BookmarkEvent, emit: Emitter<ReaderState>):
        SWITCH event.action:
            CASE BookmarkAction.ADD:
                bookmark = await bookmarkRepository.addBookmark(
                    comicId: currentComicId!,
                    pageIndex: event.pageIndex ?? state.currentPage,
                    label: event.label
                )
                newBookmarks = [...state.bookmarks, bookmark]
                emit(state.copyWith(bookmarks: newBookmarks))
            
            CASE BookmarkAction.DELETE:
                await bookmarkRepository.deleteBookmark(event.bookmarkId!)
                newBookmarks = state.bookmarks.where(b => b.id != event.bookmarkId)
                emit(state.copyWith(bookmarks: newBookmarks))
            
            CASE BookmarkAction.JUMP_TO:
                bookmark = state.bookmarks.firstWhere(b => b.id == event.bookmarkId)
                add(PageChangedEvent(
                    newPage: bookmark.pageIndex,
                    source: PageChangeSource.BOOKMARK_JUMP
                ))
    
    METHOD _onAutoPageEvent(event: AutoPageEvent, emit: Emitter<ReaderState>):
        SWITCH event.action:
            CASE AutoPageAction.START:
                _startAutoPage(event.interval ?? Duration(seconds: 5))
            CASE AutoPageAction.STOP:
                _stopAutoPage()
            CASE AutoPageAction.PAUSE:
                _pauseAutoPage()
            CASE AutoPageAction.RESUME:
                _resumeAutoPage()
    
    // Helper Methods
    METHOD _applyCustomOrder(pages: List<ComicPage>, order: List<Integer>): List<ComicPage>
        reorderedPages = List<ComicPage>(pages.length)
        FOR i = 0 TO pages.length - 1:
            newIndex = order.contains(i) ? order.indexOf(i) : i
            reorderedPages[newIndex] = pages[i]
        RETURN reorderedPages
    
    METHOD _startImagePreloading(pages: List<ComicPage>, currentPage: Integer):
        // Preload current page and adjacent pages
        preloadRange = _calculatePreloadRange(currentPage, pages.length)
        FOR pageIndex IN preloadRange:
            cacheManager.preloadImage(pages[pageIndex])
    
    METHOD _handlePageChangeEffects(event: PageChangedEvent):
        // Update navigation service
        navigationService.updateCurrentPage(event.newPage)
        
        // Platform-specific effects
        IF event.source == PageChangeSource.USER_SWIPE:
            _triggerHapticFeedback()
    
    METHOD _scheduleProgressSave():
        progressSaveTimer?.cancel()
        progressSaveTimer = Timer(Duration(seconds: 2), () {
            comicRepository.saveProgress(currentComicId!, state.currentPage)
        })
    
    METHOD _startAutoPage(interval: Duration):
        _stopAutoPage() // Stop existing timer
        autoPageTimer = Timer.periodic(interval, (timer) {
            IF state.currentPage < state.totalPages - 1:
                add(PageChangedEvent(
                    newPage: state.currentPage + 1,
                    source: PageChangeSource.AUTO_PAGE
                ))
            ELSE:
                _stopAutoPage() // Reached end
        })
    
    METHOD _stopAutoPage():
        autoPageTimer?.cancel()
        autoPageTimer = null

// =================================
// 2. UI COMPONENTS PSEUDOCODE
// =================================

// 2.1 Reader Screen (Main UI Component)
CLASS ReaderScreen EXTENDS StatelessWidget:
    PROPERTY comicId: String
    PROPERTY initialPage: Integer = 0
    
    METHOD build(context: BuildContext): Widget
        RETURN BlocProvider(
            create: (context) => ReaderBloc(
                comicRepository: GetIt.instance<IComicRepository>(),
                settingsRepository: GetIt.instance<ISettingsRepository>(),
                // ... other dependencies
            )..add(LoadComicEvent(comicId, initialPage)),
            
            child: BlocBuilder<ReaderBloc, ReaderState>(
                builder: (context, state) {
                    RETURN _buildContent(context, state)
                }
            )
        )
    
    METHOD _buildContent(context: BuildContext, state: ReaderState): Widget
        IF state.isLoading:
            RETURN _buildLoadingScreen(state.settings)
        
        IF state.error != null:
            RETURN _buildErrorScreen(state.error!, state.settings)
        
        IF !state.isValid:
            RETURN _buildEmptyScreen(state.settings)
        
        RETURN _buildReaderInterface(context, state)
    
    METHOD _buildReaderInterface(context: BuildContext, state: ReaderState): Widget
        RETURN Scaffold(
            backgroundColor: state.settings.backgroundTheme.color,
            extendBodyBehindAppBar: true,
            extendBody: true,
            
            appBar: AnimatedOpacity(
                opacity: state.isUiVisible ? 1.0 : 0.0,
                duration: Duration(milliseconds: 200),
                child: TopMenuBar(state: state)
            ),
            
            body: Stack(
                children: [
                    // Main content area
                    ReaderGestureHandler(
                        child: ReaderCore(
                            state: state,
                            onPageChanged: (page) => _dispatchEvent(
                                PageChangedEvent(page, PageChangeSource.USER_SWIPE)
                            ),
                            onZoomChanged: (scale, focalPoint) => _dispatchEvent(
                                ZoomChangedEvent(scale, focalPoint)
                            ),
                            onTap: () => _dispatchEvent(ToggleUiVisibilityEvent()),
                        )
                    ),
                    
                    // Brightness overlay
                    IF state.settings.brightnessOverlayEnabled:
                        BrightnessOverlay(brightness: state.settings.brightness),
                    
                    // Loading overlay for page changes
                    IF state.isPageLoading:
                        PageLoadingOverlay(),
                ]
            ),
            
            bottomNavigationBar: AnimatedOpacity(
                opacity: state.isUiVisible && state.settings.showProgress ? 1.0 : 0.0,
                duration: Duration(milliseconds: 200),
                child: BottomProgressBar(state: state)
            )
        )

// 2.2 Reader Core (Main Content Display)
CLASS ReaderCore EXTENDS StatefulWidget:
    PROPERTY state: ReaderState
    PROPERTY onPageChanged: Function(Integer)
    PROPERTY onZoomChanged: Function(Double, Offset?)
    PROPERTY onTap: Function()
    
CLASS _ReaderCoreState EXTENDS State<ReaderCore>:
    PROPERTY pageController: PageController
    PROPERTY transformationController: TransformationController
    
    METHOD initState():
        super.initState()
        pageController = PageController(initialPage: widget.state.currentPage)
        transformationController = TransformationController()
        _setupControllers()
    
    METHOD _setupControllers():
        // Listen to transformation changes for zoom events
        transformationController.addListener(() {
            scale = transformationController.value.getMaxScaleOnAxis()
            widget.onZoomChanged(scale, null)
        })
    
    METHOD build(context: BuildContext): Widget
        SWITCH widget.state.settings.readingMode:
            CASE ReadingMode.SINGLE:
                RETURN _buildSinglePageView()
            CASE ReadingMode.DUAL:
                RETURN _buildDualPageView()
            CASE ReadingMode.CONTINUOUS:
                RETURN _buildContinuousScrollView()
            DEFAULT:
                RETURN _buildSinglePageView()
    
    METHOD _buildSinglePageView(): Widget
        RETURN PageView.builder(
            controller: pageController,
            scrollDirection: _getScrollDirection(),
            reverse: _shouldReverse(),
            onPageChanged: widget.onPageChanged,
            itemCount: widget.state.totalPages,
            itemBuilder: (context, index) => _buildPageItem(index)
        )
    
    METHOD _buildPageItem(pageIndex: Integer): Widget
        page = widget.state.pages[pageIndex]
        
        RETURN InteractiveViewer(
            transformationController: transformationController,
            minScale: 0.5,
            maxScale: 5.0,
            panEnabled: true,
            scaleEnabled: true,
            child: GestureDetector(
                onTap: widget.onTap,
                onDoubleTap: () => _handleDoubleTap(),
                child: Container(
                    width: double.infinity,
                    height: double.infinity,
                    child: _buildImageWidget(page)
                )
            )
        )
    
    METHOD _buildImageWidget(page: ComicPage): Widget
        RETURN Image.memory(
            page.imageData,
            fit: _getImageFit(),
            filterQuality: FilterQuality.high,
            errorBuilder: (context, error, stackTrace) => _buildErrorPlaceholder(),
            loadingBuilder: (context, child, loadingProgress) {
                IF loadingProgress == null:
                    RETURN child
                RETURN _buildLoadingPlaceholder(loadingProgress)
            }
        )
    
    METHOD _getScrollDirection(): Axis
        SWITCH widget.state.settings.navigationDirection:
            CASE NavigationDirection.HORIZONTAL:
            CASE NavigationDirection.RTL:
                RETURN Axis.horizontal
            CASE NavigationDirection.VERTICAL:
                RETURN Axis.vertical
    
    METHOD _shouldReverse(): Boolean
        RETURN widget.state.settings.navigationDirection == NavigationDirection.RTL
    
    METHOD _getImageFit(): BoxFit
        SWITCH widget.state.settings.imageFit:
            CASE ImageFit.FIT_WIDTH:
                RETURN BoxFit.fitWidth
            CASE ImageFit.FIT_HEIGHT:
                RETURN BoxFit.fitHeight
            CASE ImageFit.FIT_SCREEN:
                RETURN BoxFit.contain
            CASE ImageFit.ORIGINAL:
                RETURN BoxFit.none
            DEFAULT:
                RETURN BoxFit.contain
    
    METHOD _handleDoubleTap():
        currentScale = transformationController.value.getMaxScaleOnAxis()
        
        IF currentScale <= 1.0:
            // Zoom in to 2x
            _animateToScale(2.0)
        ELSE IF currentScale <= 2.0:
            // Zoom in to fit width
            _animateToFitWidth()
        ELSE:
            // Reset to fit screen
            _animateToScale(1.0)
    
    METHOD _animateToScale(targetScale: Double):
        Animation<Matrix4> animation = Matrix4Tween(
            begin: transformationController.value,
            end: Matrix4.identity()..scale(targetScale)
        ).animate(CurvedAnimation(
            parent: AnimationController(
                duration: Duration(milliseconds: 300),
                vsync: this
            ),
            curve: Curves.easeInOut
        ))
        
        animation.addListener(() {
            transformationController.value = animation.value
        })
        
        animation.controller.forward()

// 2.3 Gesture Handler
CLASS ReaderGestureHandler EXTENDS StatefulWidget:
    PROPERTY child: Widget
    PROPERTY onTap: Function(TapInfo)?
    PROPERTY onDoubleTap: Function(TapInfo)?
    PROPERTY onLongPress: Function(TapInfo)?
    PROPERTY onPinchZoom: Function(ScaleInfo)?
    PROPERTY tapZoneConfig: TapZoneConfig

CLASS _ReaderGestureHandlerState EXTENDS State<ReaderGestureHandler>:
    METHOD build(context: BuildContext): Widget
        RETURN GestureDetector(
            onTapUp: (details) => _handleTap(details),
            onDoubleTapDown: (details) => _handleDoubleTap(details),
            onLongPressStart: (details) => _handleLongPress(details),
            onScaleStart: (details) => _handleScaleStart(details),
            onScaleUpdate: (details) => _handleScaleUpdate(details),
            onScaleEnd: (details) => _handleScaleEnd(details),
            child: widget.child
        )
    
    METHOD _handleTap(details: TapUpDetails):
        screenSize = MediaQuery.of(context).size
        tapPosition = details.localPosition
        
        tapZone = _determineTapZone(tapPosition, screenSize)
        
        tapInfo = TapInfo(
            position: tapPosition,
            zone: tapZone,
            timestamp: DateTime.now()
        )
        
        SWITCH tapZone:
            CASE TapZone.LEFT:
                _handleLeftTap(tapInfo)
            CASE TapZone.RIGHT:
                _handleRightTap(tapInfo)
            CASE TapZone.CENTER:
                _handleCenterTap(tapInfo)
    
    METHOD _determineTapZone(position: Offset, screenSize: Size): TapZone
        leftZoneWidth = screenSize.width * widget.tapZoneConfig.leftZoneRatio
        rightZoneWidth = screenSize.width * widget.tapZoneConfig.rightZoneRatio
        
        IF position.dx < leftZoneWidth:
            RETURN TapZone.LEFT
        ELSE IF position.dx > screenSize.width - rightZoneWidth:
            RETURN TapZone.RIGHT
        ELSE:
            RETURN TapZone.CENTER
    
    METHOD _handleLeftTap(tapInfo: TapInfo):
        action = widget.tapZoneConfig.leftAction
        _executeTapAction(action, tapInfo)
    
    METHOD _handleRightTap(tapInfo: TapInfo):
        action = widget.tapZoneConfig.rightAction
        _executeTapAction(action, tapInfo)
    
    METHOD _handleCenterTap(tapInfo: TapInfo):
        action = widget.tapZoneConfig.centerAction
        _executeTapAction(action, tapInfo)
    
    METHOD _executeTapAction(action: TapAction, tapInfo: TapInfo):
        SWITCH action:
            CASE TapAction.PREVIOUS_PAGE:
                context.read<ReaderBloc>().add(PageChangedEvent(
                    newPage: max(0, currentPage - 1),
                    source: PageChangeSource.TAP_NAVIGATION
                ))
            CASE TapAction.NEXT_PAGE:
                context.read<ReaderBloc>().add(PageChangedEvent(
                    newPage: min(totalPages - 1, currentPage + 1),
                    source: PageChangeSource.TAP_NAVIGATION
                ))
            CASE TapAction.TOGGLE_UI:
                context.read<ReaderBloc>().add(ToggleUiVisibilityEvent())
            CASE TapAction.CUSTOM:
                widget.onTap?.call(tapInfo)

// =================================
// 3. DATA LAYER PSEUDOCODE
// =================================

// 3.1 Comic Repository Implementation
CLASS ComicRepository IMPLEMENTS IComicRepository:
    DEPENDENCIES:
        database: DriftDatabase
        archiveService: IArchiveService
        cacheManager: ICacheManager
        fileService: IFileService
    
    METHOD getComic(comicId: String): Future<Comic>
        TRY:
            comicData = await database.getComic(comicId)
            IF comicData == null:
                THROW ComicNotFoundException(comicId)
            
            RETURN Comic.fromDatabaseModel(comicData)
        CATCH error:
            THROW RepositoryException("Failed to get comic", error)
    
    METHOD getPages(comicId: String): Future<List<ComicPage>>
        TRY:
            comic = await getComic(comicId)
            
            // Check cache first
            cachedPages = await cacheManager.getCachedPages(comicId)
            IF cachedPages != null AND cachedPages.isNotEmpty():
                RETURN cachedPages
            
            // Extract pages from archive
            archiveFile = await fileService.getFile(comic.filePath)
            extractedPages = await archiveService.extractPages(archiveFile)
            
            // Convert to ComicPage objects
            pages = List<ComicPage>()
            FOR i = 0 TO extractedPages.length - 1:
                pageData = await _processPageImage(extractedPages[i], i)
                pages.add(pageData)
            
            // Cache the processed pages
            await cacheManager.cachePages(comicId, pages)
            
            RETURN pages
            
        CATCH error:
            THROW RepositoryException("Failed to get comic pages", error)
    
    METHOD _processPageImage(imageData: Uint8List, index: Integer): Future<ComicPage>
        // Decode image to get metadata
        imageInfo = await _decodeImageInfo(imageData)
        
        // Optimize image if needed
        optimizedData = await _optimizeImage(imageData, imageInfo)
        
        RETURN ComicPage(
            index: index,
            imageData: optimizedData,
            imageSize: imageInfo.size,
            format: imageInfo.format,
            originalSize: imageData.length,
            optimizedSize: optimizedData.length
        )
    
    METHOD _optimizeImage(data: Uint8List, info: ImageInfo): Future<Uint8List>
        // Check if optimization is needed
        IF !_shouldOptimize(info):
            RETURN data
        
        // Resize if too large
        IF info.size.width > MAX_IMAGE_WIDTH OR info.size.height > MAX_IMAGE_HEIGHT:
            RETURN await _resizeImage(data, _calculateOptimalSize(info.size))
        
        // Compress if file size is too large
        IF data.length > MAX_IMAGE_FILE_SIZE:
            RETURN await _compressImage(data, _calculateCompressionQuality(data.length))
        
        RETURN data
    
    METHOD saveProgress(comicId: String, currentPage: Integer): Future<void>
        TRY:
            progress = (currentPage + 1) / await _getTotalPages(comicId)
            
            await database.updateComicProgress(
                comicId: comicId,
                currentPage: currentPage,
                progress: progress,
                lastReadAt: DateTime.now()
            )
            
            // Update reading session
            await _updateReadingSession(comicId, currentPage)
            
        CATCH error:
            THROW RepositoryException("Failed to save progress", error)
    
    METHOD getProgress(comicId: String): Future<ReadingProgress?>
        TRY:
            progressData = await database.getComicProgress(comicId)
            IF progressData == null:
                RETURN null
            
            RETURN ReadingProgress.fromDatabaseModel(progressData)
        CATCH error:
            THROW RepositoryException("Failed to get progress", error)
    
    METHOD getCustomPageOrder(comicId: String): Future<List<Integer>>
        TRY:
            orderData = await database.getCustomPageOrder(comicId)
            RETURN orderData.map(d => d.originalIndex).toList()
        CATCH error:
            RETURN [] // Return empty list if no custom order
    
    METHOD setCustomPageOrder(comicId: String, order: List<Integer>): Future<void>
        TRY:
            // Clear existing order
            await database.clearCustomPageOrder(comicId)
            
            // Save new order
            FOR i = 0 TO order.length - 1:
                await database.insertPageOrder(
                    comicId: comicId,
                    originalIndex: order[i],
                    customIndex: i
                )
        CATCH error:
            THROW RepositoryException("Failed to set custom page order", error)

// 3.2 Settings Repository Implementation
CLASS SettingsRepository IMPLEMENTS ISettingsRepository:
    DEPENDENCIES:
        sharedPrefs: SharedPreferences
        database: DriftDatabase
    
    PRIVATE_PROPERTIES:
        settingsCache: Map<String, Any> = {}
        cacheExpiry: DateTime?
    
    METHOD getSettings(): Future<ReaderSettings>
        TRY:
            // Check cache first
            IF _isCacheValid():
                RETURN _buildSettingsFromCache()
            
            // Load from persistent storage
            settingsData = await _loadAllSettings()
            
            // Update cache
            _updateCache(settingsData)
            
            RETURN ReaderSettings.fromMap(settingsData)
            
        CATCH error:
            // Return default settings on error
            RETURN ReaderSettings.defaults()
    
    METHOD saveSetting(settingType: SettingType, value: Any): Future<void>
        TRY:
            // Validate setting value
            validatedValue = _validateSettingValue(settingType, value)
            
            // Save to persistent storage
            SWITCH settingType.storageType:
                CASE StorageType.SHARED_PREFS:
                    await _saveToSharedPrefs(settingType.key, validatedValue)
                CASE StorageType.DATABASE:
                    await _saveToDatabase(settingType.key, validatedValue)
            
            // Update cache
            settingsCache[settingType.key] = validatedValue
            
            // Notify listeners
            _notifySettingChanged(settingType, validatedValue)
            
        CATCH error:
            THROW RepositoryException("Failed to save setting", error)
    
    METHOD _loadAllSettings(): Future<Map<String, Any>>
        settings = Map<String, Any>()
        
        // Load from SharedPreferences
        sharedPrefsSettings = await _loadFromSharedPrefs()
        settings.addAll(sharedPrefsSettings)
        
        // Load from Database
        databaseSettings = await _loadFromDatabase()
        settings.addAll(databaseSettings)
        
        RETURN settings
    
    METHOD _validateSettingValue(settingType: SettingType, value: Any): Any
        SWITCH settingType:
            CASE SettingType.BRIGHTNESS:
                RETURN (value as Double).clamp(0.1, 1.0)
            CASE SettingType.AUTO_PAGE_INTERVAL:
                RETURN (value as Integer).clamp(1, 60)
            CASE SettingType.CACHE_SIZE:
                RETURN (value as Integer).clamp(50, 1000)
            // ... other validations
            DEFAULT:
                RETURN value
    
    METHOD watchSettings(): Stream<ReaderSettings>
        RETURN _settingsStreamController.stream
            .map((settingsMap) => ReaderSettings.fromMap(settingsMap))

// 3.3 Bookmark Repository Implementation  
CLASS BookmarkRepository IMPLEMENTS IBookmarkRepository:
    DEPENDENCIES:
        database: DriftDatabase
        fileService: IFileService
    
    METHOD getBookmarks(comicId: String): Future<List<Bookmark>>
        TRY:
            bookmarkData = await database.getBookmarks(comicId)
            bookmarks = bookmarkData.map(data => Bookmark.fromDatabaseModel(data)).toList()
            
            // Sort by page index
            bookmarks.sort((a, b) => a.pageIndex.compareTo(b.pageIndex))
            
            RETURN bookmarks
        CATCH error:
            THROW RepositoryException("Failed to get bookmarks", error)
    
    METHOD addBookmark(comicId: String, pageIndex: Integer, label: String?): Future<Bookmark>
        TRY:
            // Check if bookmark already exists for this page
            existingBookmark = await database.getBookmarkByPage(comicId, pageIndex)
            IF existingBookmark != null:
                THROW BookmarkAlreadyExistsException(comicId, pageIndex)
            
            // Generate thumbnail
            thumbnailPath = await _generateBookmarkThumbnail(comicId, pageIndex)
            
            // Create bookmark
            bookmarkId = await database.insertBookmark(
                comicId: comicId,
                pageIndex: pageIndex,
                label: label,
                thumbnailPath: thumbnailPath,
                createdAt: DateTime.now()
            )
            
            bookmark = Bookmark(
                id: bookmarkId,
                comicId: comicId,
                pageIndex: pageIndex,
                label: label,
                thumbnailPath: thumbnailPath,
                createdAt: DateTime.now()
            )
            
            // Notify observers
            _notifyBookmarkAdded(bookmark)
            
            RETURN bookmark
            
        CATCH error:
            THROW RepositoryException("Failed to add bookmark", error)
    
    METHOD deleteBookmark(bookmarkId: String): Future<void>
        TRY:
            // Get bookmark info before deletion
            bookmark = await database.getBookmark(bookmarkId)
            IF bookmark == null:
                THROW BookmarkNotFoundException(bookmarkId)
            
            // Delete thumbnail file
            IF bookmark.thumbnailPath != null:
                await fileService.deleteFile(bookmark.thumbnailPath!)
            
            // Delete from database
            await database.deleteBookmark(bookmarkId)
            
            // Notify observers
            _notifyBookmarkDeleted(bookmark)
            
        CATCH error:
            THROW RepositoryException("Failed to delete bookmark", error)
    
    METHOD _generateBookmarkThumbnail(comicId: String, pageIndex: Integer): Future<String>
        // Get the page image data
        pages = await GetIt.instance<IComicRepository>().getPages(comicId)
        pageData = pages[pageIndex]
        
        // Create thumbnail
        thumbnailData = await _createThumbnail(pageData.imageData, Size(150, 200))
        
        // Save thumbnail file
        thumbnailPath = "bookmarks/${comicId}_${pageIndex}_thumb.jpg"
        await fileService.saveFile(thumbnailPath, thumbnailData)
        
        RETURN thumbnailPath

// =================================
// 4. SERVICE LAYER PSEUDOCODE
// =================================

// 4.1 Cache Manager Implementation
CLASS CacheManager IMPLEMENTS ICacheManager:
    PRIVATE_PROPERTIES:
        memoryCache: LRUCache<String, ComicPage>
        diskCache: DiskLRUCache
        maxMemorySize: Integer = 100 * 1024 * 1024 // 100MB
        maxDiskSize: Integer = 500 * 1024 * 1024   // 500MB
        preloadQueue: PriorityQueue<PreloadRequest>
        
    CONSTRUCTOR():
        memoryCache = LRUCache(maxMemorySize)
        diskCache = DiskLRUCache(maxDiskSize)
        _initializeCleanupTimer()
    
    METHOD getCachedPages(comicId: String): Future<List<ComicPage>?>
        TRY:
            // Check memory cache first
            memoryCacheKey = "pages_$comicId"
            cachedPages = memoryCache.get(memoryCacheKey)
            IF cachedPages != null:
                RETURN cachedPages
            
            // Check disk cache
            diskCacheKey = "comic_pages_$comicId"
            diskCachedData = await diskCache.get(diskCacheKey)
            IF diskCachedData != null:
                pages = await _deserializePages(diskCachedData)
                
                // Store in memory cache for faster access
                memoryCache.put(memoryCacheKey, pages)
                
                RETURN pages
            
            RETURN null
        CATCH error:
            RETURN null // Return null on cache miss or error
    
    METHOD cachePages(comicId: String, pages: List<ComicPage>): Future<void>
        TRY:
            // Cache in memory
            memoryCacheKey = "pages_$comicId"
            memoryCache.put(memoryCacheKey, pages)
            
            // Cache on disk (async)
            _cachePagesOnDisk(comicId, pages)
            
        CATCH error:
            // Log error but don't throw - caching is not critical
            print("Failed to cache pages: $error")
    
    METHOD preloadImage(page: ComicPage, priority: Integer = 5): Future<void>
        request = PreloadRequest(
            page: page,
            priority: priority,
            timestamp: DateTime.now()
        )
        
        preloadQueue.add(request)
        _processPreloadQueue()
    
    METHOD _processPreloadQueue(): Future<void>
        WHILE preloadQueue.isNotEmpty:
            request = preloadQueue.removeFirst()
            
            // Check if already cached
            IF _isPageCached(request.page):
                CONTINUE
            
            TRY:
                // Process image for optimal display
                processedData = await _optimizeImageForDisplay(request.page.imageData)
                
                // Cache the processed image
                await _cacheProcessedImage(request.page.index, processedData)
                
            CATCH error:
                print("Failed to preload image: $error")
    
    METHOD _optimizeImageForDisplay(imageData: Uint8List): Future<Uint8List>
        // Decode image
        image = await decodeImageFromList(imageData)
        
        // Calculate optimal size for current screen
        screenSize = WidgetsBinding.instance.window.physicalSize
        optimalSize = _calculateOptimalImageSize(image.width, image.height, screenSize)
        
        // Resize if needed
        IF image.width > optimalSize.width OR image.height > optimalSize.height:
            resizedImage = await _resizeImage(image, optimalSize)
            RETURN await _encodeImage(resizedImage)
        
        RETURN imageData
    
    METHOD clearCache(type: CacheType = CacheType.ALL): Future<void>
        SWITCH type:
            CASE CacheType.MEMORY:
                memoryCache.clear()
            CASE CacheType.DISK:
                await diskCache.clear()
            CASE CacheType.ALL:
                memoryCache.clear()
                await diskCache.clear()
    
    METHOD getCacheStats(): CacheStats
        RETURN CacheStats(
            memoryUsage: memoryCache.currentSize,
            memoryLimit: maxMemorySize,
            diskUsage: diskCache.size(),
            diskLimit: maxDiskSize,
            hitRate: _calculateHitRate(),
            preloadQueueSize: preloadQueue.length
        )

// 4.2 Navigation Service Implementation
CLASS NavigationService IMPLEMENTS INavigationService:
    PRIVATE_PROPERTIES:
        currentPage: Integer = 0
        totalPages: Integer = 0
        navigationHistory: List<Integer> = []
        maxHistorySize: Integer = 50
        
    METHOD goToPage(page: Integer, saveToHistory: Boolean = true): Boolean
        IF page < 0 OR page >= totalPages:
            RETURN false
        
        IF saveToHistory:
            _addToHistory(currentPage)
        
        oldPage = currentPage
        currentPage = page
        
        _notifyPageChanged(oldPage, currentPage)
        RETURN true
    
    METHOD goToNextPage(): Boolean
        RETURN goToPage(currentPage + 1)
    
    METHOD goToPreviousPage(): Boolean
        RETURN goToPage(currentPage - 1)
    
    METHOD goBack(): Boolean
        IF navigationHistory.isEmpty:
            RETURN false
        
        previousPage = navigationHistory.removeLast()
        RETURN goToPage(previousPage, false) // Don't save to history
    
    METHOD canGoNext(): Boolean
        RETURN currentPage < totalPages - 1
    
    METHOD canGoPrevious(): Boolean
        RETURN currentPage > 0
    
    METHOD canGoBack(): Boolean
        RETURN navigationHistory.isNotEmpty
    
    METHOD jumpToBookmark(bookmark: Bookmark): Boolean
        success = goToPage(bookmark.pageIndex)
        IF success:
            _notifyBookmarkJump(bookmark)
        RETURN success
    
    METHOD _addToHistory(page: Integer):
        // Avoid adding duplicate consecutive pages
        IF navigationHistory.isNotEmpty AND navigationHistory.last == page:
            RETURN
        
        navigationHistory.add(page)
        
        // Limit history size
        WHILE navigationHistory.length > maxHistorySize:
            navigationHistory.removeAt(0)
    
    METHOD _notifyPageChanged(oldPage: Integer, newPage: Integer):
        _pageChangeStreamController.add(PageChangeEvent(
            oldPage: oldPage,
            newPage: newPage,
            timestamp: DateTime.now()
        ))

// 4.3 Auto Page Service Implementation
CLASS AutoPageService:
    PRIVATE_PROPERTIES:
        timer: Timer?
        interval: Duration = Duration(seconds: 5)
        isRunning: Boolean = false
        isPaused: Boolean = false
        onPageChange: Function()?
        
    METHOD start(interval: Duration, onPageChange: Function()):
        stop() // Stop any existing timer
        
        this.interval = interval
        this.onPageChange = onPageChange
        this.isRunning = true
        this.isPaused = false
        
        _startTimer()
    
    METHOD stop():
        timer?.cancel()
        timer = null
        isRunning = false
        isPaused = false
    
    METHOD pause():
        IF isRunning:
            timer?.cancel()
            isPaused = true
    
    METHOD resume():
        IF isRunning AND isPaused:
            isPaused = false
            _startTimer()
    
    METHOD _startTimer():
        timer = Timer.periodic(interval, (timer) {
            IF !isPaused:
                onPageChange?.call()
        })
    
    METHOD updateInterval(newInterval: Duration):
        interval = newInterval
        IF isRunning AND !isPaused:
            stop()
            start(interval, onPageChange)

// =================================
// 5. PLATFORM SERVICES PSEUDOCODE
// =================================

// 5.1 Brightness Service Implementation  
CLASS BrightnessService IMPLEMENTS IBrightnessService:
    PRIVATE_PROPERTIES:
        systemBrightness: Double?
        customBrightness: Double = 1.0
        isOverrideEnabled: Boolean = false
        
    METHOD getSystemBrightness(): Future<Double>
        TRY:
            brightness = await ScreenBrightness().current
            RETURN brightness
        CATCH error:
            RETURN 1.0 // Default brightness
    
    METHOD setSystemBrightness(brightness: Double): Future<void>
        clampedBrightness = brightness.clamp(0.0, 1.0)
        
        TRY:
            await ScreenBrightness().setScreenBrightness(clampedBrightness)
        CATCH error:
            THROW BrightnessException("Failed to set system brightness", error)
    
    METHOD enableBrightnessOverride(brightness: Double): Future<void>
        // Save current system brightness
        IF !isOverrideEnabled:
            systemBrightness = await getSystemBrightness()
        
        customBrightness = brightness.clamp(0.1, 1.0)
        isOverrideEnabled = true
        
        // Apply custom brightness
        await setSystemBrightness(customBrightness)
    
    METHOD disableBrightnessOverride(): Future<void>
        IF isOverrideEnabled AND systemBrightness != null:
            // Restore original system brightness
            await setSystemBrightness(systemBrightness!)
            systemBrightness = null
            isOverrideEnabled = false
    
    METHOD autoAdjustBrightness(): Future<void>
        TRY:
            // Get ambient light level (if available)
            lightLevel = await _getAmbientLightLevel()
            
            // Calculate optimal brightness
            optimalBrightness = _calculateOptimalBrightness(lightLevel)
            
            // Apply brightness
            await enableBrightnessOverride(optimalBrightness)
            
        CATCH error:
            // Fallback to medium brightness
            await enableBrightnessOverride(0.7)
    
    METHOD _getAmbientLightLevel(): Future<Double>
        TRY:
            // Use light sensor if available
            sensorData = await LightSensor().luxStream.first
            RETURN sensorData / 1000.0 // Normalize to 0-1 range
        CATCH error:
            RETURN 0.5 // Default medium light level
    
    METHOD _calculateOptimalBrightness(lightLevel: Double): Double
        // Simple algorithm - can be made more sophisticated
        IF lightLevel < 0.1:
            RETURN 0.3 // Very dim for dark environments
        ELSE IF lightLevel < 0.5:
            RETURN 0.6 // Medium brightness
        ELSE:
            RETURN 0.9 // High brightness for bright environments

// 5.2 Wakelock Service Implementation
CLASS WakelockService:
    PRIVATE_PROPERTIES:
        isWakelockEnabled: Boolean = false
        
    METHOD enableWakelock(): Future<void>
        TRY:
            await Wakelock.enable()
            isWakelockEnabled = true
        CATCH error:
            THROW WakelockException("Failed to enable wakelock", error)
    
    METHOD disableWakelock(): Future<void>
        TRY:
            await Wakelock.disable()
            isWakelockEnabled = false
        CATCH error:
            THROW WakelockException("Failed to disable wakelock", error)
    
    METHOD isEnabled(): Future<Boolean>
        TRY:
            RETURN await Wakelock.enabled
        CATCH error:
            RETURN false

// 5.3 Hardware Buttons Service Implementation
CLASS HardwareButtonsService:
    PRIVATE_PROPERTIES:
        subscription: StreamSubscription?
        onVolumeUp: Function()?
        onVolumeDown: Function()?
        
    METHOD initialize(onVolumeUp: Function(), onVolumeDown: Function()):
        this.onVolumeUp = onVolumeUp
        this.onVolumeDown = onVolumeDown
        
        TRY:
            subscription = HardwareButtons.volumeButtonEvents.listen((event) {
                SWITCH event:
                    CASE VolumeButtonEvent.VOLUME_UP:
                        this.onVolumeUp?.call()
                    CASE VolumeButtonEvent.VOLUME_DOWN:
                        this.onVolumeDown?.call()
            })
        CATCH error:
            print("Failed to initialize hardware buttons: $error")
    
    METHOD dispose():
        subscription?.cancel()
        subscription = null

// =================================
// 6. PERFORMANCE OPTIMIZATION ALGORITHMS
// =================================

// 6.1 LRU Cache Implementation
CLASS LRUCache<K, V>:
    PRIVATE_PROPERTIES:
        maxSize: Integer
        cache: LinkedHashMap<K, CacheEntry<V>>
        currentSize: Integer = 0
        
    CLASS CacheEntry<V>:
        PROPERTY value: V
        PROPERTY size: Integer
        PROPERTY accessTime: DateTime
    
    METHOD get(key: K): V?
        entry = cache[key]
        IF entry == null:
            RETURN null
        
        // Update access time and move to end (most recently used)
        entry.accessTime = DateTime.now()
        cache.remove(key)
        cache[key] = entry
        
        RETURN entry.value
    
    METHOD put(key: K, value: V, size: Integer):
        // Remove existing entry if present
        IF cache.containsKey(key):
            oldEntry = cache.remove(key)!
            currentSize -= oldEntry.size
        
        // Create new entry
        entry = CacheEntry(
            value: value,
            size: size,
            accessTime: DateTime.now()
        )
        
        // Ensure we have space
        _ensureCapacity(size)
        
        // Add new entry
        cache[key] = entry
        currentSize += size
    
    METHOD _ensureCapacity(requiredSize: Integer):
        WHILE currentSize + requiredSize > maxSize AND cache.isNotEmpty:
            // Remove least recently used item (first in LinkedHashMap)
            firstKey = cache.keys.first
            removedEntry = cache.remove(firstKey)!
            currentSize -= removedEntry.size

// 6.2 Image Optimization Algorithm
FUNCTION optimizeImageForReading(imageData: Uint8List, targetSize: Size): Future<Uint8List>
    // Decode image
    originalImage = await decodeImageFromList(imageData)
    
    // Calculate optimal dimensions
    optimalSize = _calculateOptimalSize(originalImage, targetSize)
    
    // Skip optimization if image is already optimal
    IF _isOptimal(originalImage, optimalSize):
        RETURN imageData
    
    // Resize image
    resizedImage = await _resizeImage(originalImage, optimalSize)
    
    // Compress with optimal quality
    quality = _calculateOptimalQuality(resizedImage)
    optimizedData = await _compressImage(resizedImage, quality)
    
    RETURN optimizedData

FUNCTION _calculateOptimalSize(original: Image, target: Size): Size
    aspectRatio = original.width / original.height
    targetAspectRatio = target.width / target.height
    
    IF aspectRatio > targetAspectRatio:
        // Image is wider - fit to width
        optimalWidth = target.width
        optimalHeight = optimalWidth / aspectRatio
    ELSE:
        // Image is taller - fit to height  
        optimalHeight = target.height
        optimalWidth = optimalHeight * aspectRatio
    
    // Ensure minimum size for readability
    minWidth = 800
    minHeight = 600
    
    RETURN Size(
        max(optimalWidth, minWidth),
        max(optimalHeight, minHeight)
    )

// =================================
// 7. ERROR HANDLING & RECOVERY
// =================================

// 7.1 Error Types Definition
ABSTRACT CLASS ReaderException EXTENDS Exception:
    PROPERTY message: String
    PROPERTY cause: Exception?
    PROPERTY timestamp: DateTime
    
    CONSTRUCTOR(message: String, cause: Exception? = null):
        this.message = message
        this.cause = cause
        this.timestamp = DateTime.now()

CLASS ComicNotFoundException EXTENDS ReaderException:
    PROPERTY comicId: String
    
    CONSTRUCTOR(comicId: String):
        super("Comic not found: $comicId")
        this.comicId = comicId

CLASS PageLoadException EXTENDS ReaderException:
    PROPERTY pageIndex: Integer
    
    CONSTRUCTOR(pageIndex: Integer, cause: Exception):
        super("Failed to load page $pageIndex", cause)
        this.pageIndex = pageIndex

CLASS CacheException EXTENDS ReaderException:
    PROPERTY operation: String
    
    CONSTRUCTOR(operation: String, cause: Exception):
        super("Cache operation failed: $operation", cause)
        this.operation = operation

// 7.2 Error Recovery Manager
CLASS ErrorRecoveryManager:
    PRIVATE_PROPERTIES:
        maxRetries: Integer = 3
        retryDelays: List<Duration> = [
            Duration(seconds: 1),
            Duration(seconds: 3),
            Duration(seconds: 5)
        ]
    
    METHOD handleError<T>(
        operation: Function(): Future<T>,
        errorHandler: Function(Exception): T,
        retryCondition: Function(Exception): Boolean = defaultRetryCondition
    ): Future<T>
        
        FOR attempt = 0 TO maxRetries:
            TRY:
                RETURN await operation()
            CATCH error:
                IF attempt == maxRetries OR !retryCondition(error):
                    RETURN errorHandler(error)
                
                // Wait before retry
                await Future.delayed(retryDelays[attempt])
        
        // This should never be reached, but satisfy the compiler
        THROW Exception("Unexpected error in retry logic")
    
    METHOD defaultRetryCondition(error: Exception): Boolean
        // Retry for network and temporary file system errors
        RETURN error is NetworkException OR 
               error is FileSystemException OR
               error is CacheException

// =================================
// 8. MAIN INTEGRATION & BOOTSTRAP
// =================================

// 8.1 Application Bootstrap
CLASS ReaderAppBootstrap:
    METHOD initialize(): Future<void>
        // Initialize core services
        await _initializeServices()
        
        // Setup error handling
        _setupErrorHandling()
        
        // Initialize platform services
        await _initializePlatformServices()
        
        // Load user preferences
        await _loadUserPreferences()
        
        // Setup analytics
        _setupAnalytics()
    
    METHOD _initializeServices():
        // Register repositories
        GetIt.instance.registerLazySingleton<IComicRepository>(
            () => ComicRepository(
                database: GetIt.instance<DriftDatabase>(),
                archiveService: GetIt.instance<IArchiveService>(),
                cacheManager: GetIt.instance<ICacheManager>(),
                fileService: GetIt.instance<IFileService>()
            )
        )
        
        GetIt.instance.registerLazySingleton<ISettingsRepository>(
            () => SettingsRepository(
                sharedPrefs: GetIt.instance<SharedPreferences>(),
                database: GetIt.instance<DriftDatabase>()
            )
        )
        
        GetIt.instance.registerLazySingleton<IBookmarkRepository>(
            () => BookmarkRepository(
                database: GetIt.instance<DriftDatabase>(),
                fileService: GetIt.instance<IFileService>()
            )
        )
        
        // Register services
        GetIt.instance.registerLazySingleton<ICacheManager>(
            () => CacheManager()
        )
        
        GetIt.instance.registerLazySingleton<INavigationService>(
            () => NavigationService()
        )
    
    METHOD _setupErrorHandling():
        FlutterError.onError = (FlutterErrorDetails details) {
            // Log error
            _logError(details.exception, details.stack)
            
            // Report to crash analytics
            FirebaseCrashlytics.instance.recordFlutterError(details)
        }
        
        PlatformDispatcher.instance.onError = (error, stack) {
            _logError(error, stack)
            FirebaseCrashlytics.instance.recordError(error, stack)
            RETURN true
        }

// 8.2 Main Application Entry Point
FUNCTION main(): Future<void>
    // Ensure Flutter is initialized
    WidgetsFlutterBinding.ensureInitialized()
    
    // Initialize Firebase
    await Firebase.initializeApp()
    
    // Bootstrap application
    bootstrap = ReaderAppBootstrap()
    await bootstrap.initialize()
    
    // Run the app
    runApp(ReaderApp())

CLASS ReaderApp EXTENDS StatelessWidget:
    METHOD build(context: BuildContext): Widget
        RETURN MaterialApp(
            title: 'Easy Comic Reader',
            theme: _buildLightTheme(),
            darkTheme: _buildDarkTheme(),
            themeMode: ThemeMode.system,
            
            // Route configuration
            initialRoute: '/home',
            routes: {
                '/home': (context) => HomePage(),
                '/reader': (context) => ReaderPage(
                    comicId: ModalRoute.of(context)!.settings.arguments as String
                ),
            },
            
            // Error handling
            builder: (context, child) {
                ErrorWidget.builder = (FlutterErrorDetails errorDetails) {
                    RETURN ErrorDisplayWidget(error: errorDetails)
                }
                RETURN child!
            }
        )

// END OF PSEUDOCODE SPECIFICATION