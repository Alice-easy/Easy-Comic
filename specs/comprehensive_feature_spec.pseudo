# 全功能修复与增强伪代码规范
# 版本: 1.0
# 日期: 2025-08-01

# ---
# 简介
# ---
# 本文档为 "Easy-Comic" Flutter 应用的核心功能修复和新功能实现提供了详细的伪代码和技术规范。
# 遵循 Clean Architecture + BLoC + Repository 模式。
# 文档涵盖了从应用启动、数据持久化到高级功能（如 WebDAV 同步）的各个方面，
# 作为开发团队的统一蓝图。
# ---
# ---
# 模块 1: 应用启动和架构修复 (MOD-01)
# ---

## 1.1 目标
# - 验证并巩固基于 Clean Architecture 的应用启动流程。
# - 确保所有核心服务和依赖项都通过 GetIt 正确初始化。
# - 建立稳定的应用入口点，为后续功能开发奠定基础。

## 1.2 `main.dart` 启动流程伪代码

FUNCTION main():
  # 确保 Flutter 绑定已初始化，这对于调用平台通道代码至关重要。
  WidgetsFlutterBinding.ensureInitialized()

  # 设置全局错误处理
  setupGlobalErrorHandler()

  # 初始化依赖注入容器
  # 这是应用所有服务的入口，例如数据库、仓库、Blocs
  await di.init() # di 代表 dependency injection
  
  # 运行 Flutter 应用
  runApp(App())
END FUNCTION

## 1.3 依赖注入 (`injection_container.dart`) 伪代码

# 使用 GetIt 作为服务定位器
CLASS DependencyInjectionContainer:
  FUNCTION init():
    # 核心服务 (Core)
    register SharedPreferences instance
    register WebDavClient instance
    register LoggingService as lazy singleton
    register CacheService as lazy singleton (配置 LRU 和内存限制)
    
    # 数据源 (DataSources)
    register SettingsLocalDataSource as lazy singleton (requires SharedPreferences)
    register ComicLocalDataSource as lazy singleton (requires DriftDatabase)
    register BookmarkLocalDataSource as lazy singleton (requires DriftDatabase)
    register WebDavRemoteDataSource as lazy singleton (requires WebDavClient)

    # 数据库 (Drift)
    register AppDatabase as lazy singleton
    
    # 仓库 (Repositories)
    register SettingsRepository as lazy singleton (implements ISettingsRepository)
    register ComicRepository as lazy singleton (implements IComicRepository)
    register BookmarkRepository as lazy singleton (implements IBookmarkRepository)
    register SyncRepository as lazy singleton (implements ISyncRepository)

    # UseCases (Domain)
    # -- 书架 --
    register GetBookshelvesUseCase (requires ComicRepository)
    register AddComicToBookshelfUseCase (requires ComicRepository)
    # -- 收藏 --
    register GetFavoritesUseCase (requires BookmarkRepository)
    # ... 为每个业务操作注册 UseCase
    
    # BLoCs (Presentation)
    register factory HomeBloc (requires GetBookshelvesUseCase)
    register factory ReaderBloc (requires ComicRepository, SettingsRepository)
    register factory SettingsBloc (requires SettingsRepository)
    register factory FavoritesBloc (requires GetFavoritesUseCase)
    # ... 为每个页面或复杂组件注册 Bloc
  END FUNCTION
END CLASS

## 1.4 应用主入口 (`App.dart`) 伪代码

CLASS App EXTENDS StatelessWidget:
  FUNCTION build(context):
    # 使用 BlocProvider 来提供全局的 Bloc，例如主题管理
    RETURN BlocProvider(
      create: (_) => di.sl<ThemeBloc>()..add(LoadThemeEvent()),
      child: BlocBuilder<ThemeBloc, ThemeState>(
        builder: (context, themeState) =>
          MaterialApp(
            title: 'Easy-Comic',
            theme: themeState.lightTheme,
            darkTheme: themeState.darkTheme,
            themeMode: themeState.themeMode,
            
            # 路由管理
            onGenerateRoute: AppRouter.onGenerateRoute,
            initialRoute: AppRoutes.home,
          )
      )
    )
  END FUNCTION
END CLASS

## 1.5 路由管理 (`AppRouter.dart`) 伪代码

CLASS AppRouter:
  STATIC FUNCTION onGenerateRoute(settings):
    SWITCH settings.name:
      CASE AppRoutes.home:
        RETURN MaterialPageRoute(builder: (_) => HomeScreen())
      CASE AppRoutes.reader:
        # 传递漫画 ID
        comicId = settings.arguments AS String
        RETURN MaterialPageRoute(builder: (_) => ReaderScreen(comicId: comicId))
      CASE AppRoutes.settings:
        RETURN MaterialPageRoute(builder: (_) => SettingsScreen())
      DEFAULT:
        RETURN MaterialPageRoute(builder: (_) => NotFoundScreen())
    END SWITCH
  END FUNCTION
END CLASS

## 1.6 依赖项 (`pubspec.yaml`) 修复检查清单
# - [ ] flutter_bloc: 用于 BLoC 状态管理
# - [ ] get_it: 用于依赖注入
# - [ ] drift / sqflite: 用于本地数据库
# - [ ] shared_preferences: 用于键值对存储
# - [ ] dartz: 用于函数式编程 (Either 类型)
# - [ ] webdav_client: 用于 WebDAV 同步
# - [ ] path_provider: 用于获取文件系统路径
# - [ ] archive: 用于解压漫画文件
# - [ ] cached_network_image: (或自定义缓存) 用于图像缓存
# - 检查所有依赖项版本，确保兼容性，解决潜在冲突。
# ---
# 模块 2: 数据持久化和同步 (MOD-02)
# ---

## 2.1 目标
# - 使用 Drift (SQLite) 建立一个健壮的本地数据库来存储应用核心数据。
# - 使用 SharedPreferences 管理用户设置和应用配置。
# - 为数据备份和恢复定义清晰的 JSON 序列化/反序列化契约。

## 2.2 Drift 数据库表结构 (`database.dart`)

# AppDatabase 使用 Drift 来管理数据库
DATABASE AppDatabase:

  # -- 漫画核心信息表 --
  TABLE Comics:
    id: STRING (主键, UUID)
    filePath: STRING (唯一)
    fileName: STRING
    coverPath: STRING (本地缓存的封面图片路径)
    pageCount: INT
    addTime: DATETIME
    lastReadTime: DATETIME
    progress: INT (已读页数)
    bookshelfId: INT (外键，关联到 Bookshelves 表)
    isFavorite: BOOLEAN
    tags: STRING (JSON 编码的标签列表)
    metadata: STRING (JSON 编码的漫画元数据, e.g., 作者, 年份)
  END TABLE

  # -- 书架表 --
  TABLE Bookshelves:
    id: INT (主键, 自增)
    name: STRING (唯一, e.g., "阅读中", "已完成")
    coverImage: STRING (书架封面)
    createTime: DATETIME
  END TABLE

  # -- 收藏夹表 --
  # 收藏夹功能与 Comic 表中的 isFavorite 字段和 tags 字段结合使用。
  # 为了更灵活的组织，可以创建一个单独的 Favorites 表，允许多层级收藏。
  TABLE Favorites:
    id: INT (主键, 自增)
    name: STRING (收藏夹名称, e.g., "经典武侠", "科幻精选")
    parentId: INT (自引用，用于实现层级结构, NULL 表示根目录)
    description: STRING
    createTime: DATETIME
  END TABLE
  
  # -- 漫画与收藏夹关联表 --
  TABLE ComicFavoriteLinks:
    comicId: STRING (外键，关联到 Comics 表)
    favoriteId: INT (外键，关联到 Favorites 表)
    PRIMARY KEY (comicId, favoriteId)
  END TABLE

  # -- 阅读历史记录表 --
  # 注意：虽然 Comics 表有 lastReadTime，但独立的日志表可以提供更详细的历史记录
  TABLE ReadingHistory:
    id: INT (主键, 自增)
    comicId: STRING (外键)
    pageNumber: INT
    timestamp: DATETIME
  END TABLE

## 2.3 SharedPreferences 设置服务伪代码 (`settings_service.dart`)

INTERFACE ISettingsService:
  FUNCTION getThemeMode(): FUTURE<ThemeMode>
  FUNCTION setThemeMode(mode): FUTURE<VOID>

  FUNCTION getReadingDirection(): FUTURE<ReadingDirection>
  FUNCTION setReadingDirection(direction): FUTURE<VOID>
  
  FUNCTION getAutoPageInterval(): FUTURE<INT>
  FUNCTION setAutoPageInterval(seconds): FUTURE<VOID>
  
  FUNCTION getWebDavConfig(): FUTURE<WebDavConfig>
  FUNCTION setWebDavConfig(config): FUTURE<VOID>
END INTERFACE

CLASS SettingsServiceImpl IMPLEMENTS ISettingsService:
  PRIVATE sharedPrefs: SharedPreferences

  CONSTRUCTOR(this.sharedPrefs)

  FUNCTION getThemeMode():
    key = 'themeMode'
    storedValue = sharedPrefs.getString(key)
    RETURN storedValue aS ThemeMode or default ThemeMode.system
  END FUNCTION
  
  FUNCTION setThemeMode(mode):
    key = 'themeMode'
    await sharedPrefs.setString(key, mode.toString())
  END FUNCTION

  # ... 实现接口中的其他方法 ...

  FUNCTION getWebDavConfig():
    # 从 SharedPreferences 读取 JSON 字符串并反序列化为 WebDavConfig 对象
    jsonString = sharedPrefs.getString('webdav_config')
    IF jsonString IS NOT NULL:
      RETURN WebDavConfig.fromJson(jsonDecode(jsonString))
    ELSE:
      RETURN NULL
    END IF
  END FUNCTION

  FUNCTION setWebDavConfig(config):
    # 将 WebDavConfig 对象序列化为 JSON 字符串并存储
    jsonString = jsonEncode(config.toJson())
    await sharedPrefs.setString('webdav_config', jsonString)
  END FUNCTION

END CLASS

## 2.4 数据备份 JSON 结构

# 定义用于导入/导出的数据结构。
# 这可以是一个包含所有应用数据的单一 JSON 对象。
# 示例 `backup.json`:
# {
#   "version": 1,
#   "exportDate": "2025-08-01T12:00:00Z",
#   "settings": { ... }, // SharedPreferences 的内容
#   "database": {
#     "comics": [ { "id": "...", "filePath": "...", ... } ],
#     "bookshelves": [ { "id": 1, "name": "..." } ],
#     "favorites": [ { "id": 1, "name": "...", "parentId": null } ],
#     "comicFavoriteLinks": [ { "comicId": "...", "favoriteId": 1 } ]
#   }
# }

CLASS BackupData:
  version: INT
  exportDate: DATETIME
  settings: Map<String, dynamic>
  database: DatabaseBackup

  FUNCTION toJson(): Map<String, dynamic>
END CLASS

CLASS DatabaseBackup:
  comics: List<Comic>
  bookshelves: List<Bookshelf>
  # ... 其他表
  
  FUNCTION toJson(): Map<String, dynamic>
END CLASS
# ---
# 模块 3: 书架功能 (MOD-03)
# ---

## 3.1 目标
# - 提供一个直观的界面来浏览和管理用户导入的所有漫画。
# - 支持多种视图模式（网格/列表）、排序和搜索。
# - 实现高效的封面加载和元数据管理。
# - 支持批量操作以增强管理效率。

## 3.2 书架 (Home) BLoC 伪代码 (`home_bloc.dart`)

# -- Events --
ABSTRACT CLASS HomeEvent {}
CLASS LoadBookshelf extends HomeEvent { bookshelfId: INT }
CLASS SearchComics extends HomeEvent { query: STRING }
CLASS SortComics extends HomeEvent { sortBy: SortField, order: SortOrder }
CLASS ChangeViewMode extends HomeEvent { viewMode: ViewMode }
CLASS EnterSelectionMode extends HomeEvent {}
CLASS ExitSelectionMode extends HomeEvent {}
CLASS ToggleComicSelection extends HomeEvent { comicId: STRING }
CLASS DeleteSelectedComics extends HomeEvent {}

# -- States --
ABSTRACT CLASS HomeState {}
CLASS HomeInitial extends HomeState {}
CLASS HomeLoading extends HomeState {}
CLASS HomeLoaded extends HomeState {
  comics: List<Comic>
  currentBookshelf: Bookshelf
  viewMode: ViewMode # Grid or List
  searchQuery: STRING
  sortBy: SortField
  sortOrder: SortOrder
  isSelectionMode: BOOLEAN
  selectedComicIds: Set<STRING>
}
CLASS HomeError extends HomeState { message: STRING }


# -- BLoC --
CLASS HomeBloc EXTENDS Bloc<HomeEvent, HomeState>:
  PRIVATE getComicsUseCase: GetComicsUseCase
  PRIVATE deleteComicsUseCase: DeleteComicsUseCase
  
  CONSTRUCTOR(this.getComicsUseCase, this.deleteComicsUseCase):
    super(HomeInitial())
    
    on<LoadBookshelf>(mapLoadBookshelfToState)
    on<SearchComics>(mapSearchComicsToState)
    on<SortComics>(mapSortComicsToState)
    # ... 其他事件处理器
    on<DeleteSelectedComics>(mapDeleteSelectedComicsToState)
  END CONSTRUCTOR

  FUNCTION mapLoadBookshelfToState(event, emit):
    emit(HomeLoading())
    result = await getComicsUseCase(bookshelfId: event.bookshelfId)
    result.fold(
      (failure) => emit(HomeError(failure.message)),
      (comics) => emit(HomeLoaded(comics: comics, ...))
    )
  END FUNCTION
  
  FUNCTION mapDeleteSelectedComicsToState(event, emit):
    IF state IS HomeLoaded:
      loadedState = state as HomeLoaded
      comicIdsToDelete = loadedState.selectedComicIds
      result = await deleteComicsUseCase(comicIdsToDelete)
      result.fold(
        (failure) => emit(HomeError(failure.message)),
        # 删除成功后重新加载书架
        (_) => add(LoadBookshelf(loadedState.currentBookshelf.id)) 
      )
    END IF
  END FUNCTION

  # ... 其他事件处理器的实现
  
END CLASS

## 3.3 书架 UI 伪代码 (`home_screen.dart`)

CLASS HomeScreen EXTENDS StatelessWidget:
  FUNCTION build(context):
    RETURN BlocProvider(
      create: (_) => di.sl<HomeBloc>()..add(LoadBookshelf(defaultBookshelfId)),
      child: Scaffold(
        appBar: buildAppBar(),
        body: BlocBuilder<HomeBloc, HomeState>(
          builder: (context, state) =>
            IF state IS HomeLoading:
              RETURN CircularProgressIndicator()
            ELSE IF state IS HomeLoaded:
              RETURN buildBookshelfView(state)
            ELSE IF state IS HomeError:
              RETURN Text(state.message)
            ELSE:
              RETURN Container()
        ),
        floatingActionButton: FloatingActionButton(
          onPressed: () => # 触发文件导入流程
        )
      )
    )
  END FUNCTION

  FUNCTION buildAppBar(context, state):
    IF state.isSelectionMode:
      RETURN AppBar(
        title: Text('${state.selectedComicIds.length} selected'),
        actions: [
          IconButton(icon: Icon(Icons.delete), onPressed: () => context.read<HomeBloc>().add(DeleteSelectedComics())),
          # 其他批量操作按钮
        ]
      )
    ELSE:
      RETURN AppBar(
        title: Text('书架'),
        actions: [
          IconButton(icon: Icon(Icons.search), onPressed: () => # 显示搜索栏),
          IconButton(icon: Icon(Icons.sort), onPressed: () => # 显示排序选项),
          IconButton(icon: Icon(Icons.view_module/view_list), onPressed: () => # 切换视图)
        ]
      )
    END IF
  END FUNCTION

  FUNCTION buildBookshelfView(state):
    IF state.viewMode == ViewMode.Grid:
      RETURN GridView.builder(...)
    ELSE:
      RETURN ListView.builder(...)
  END FUNCTION
  
END CLASS

## 3.4 漫画封面缓存和加载

# 封面加载流程
# 1. 在文件导入时，使用 `archive` 包解压漫画文件，提取第一张图片作为封面。
# 2. 将提取的封面图片存储到应用的可缓存目录中（使用 `path_provider`）。
# 3. 将封面的文件路径保存到 `Comics` 表的 `coverPath` 字段。
# 4. 在 UI 层，使用 `Image.file(comic.coverPath)` 来显示封面。
# 5. 对于列表/网格视图，采用懒加载策略，仅加载视口内可见的封面。

COMPONENT ComicGridItem(comic):
  FUNCTION build(context):
    RETURN GestureDetector(
      onTap: () => Navigator.push(ReaderScreen(comic.id)),
      onLongPress: () => context.read<HomeBloc>().add(EnterSelectionMode()),
      child: Column(
        children: [
          # 使用 FadeInImage 提供占位符和加载动画
          FadeInImage(
            placeholder: AssetImage('assets/placeholder.png'),
            image: FileImage(File(comic.coverPath)),
            fit: BoxFit.cover
          ),
          Text(comic.fileName)
        ]
      )
    )
  END FUNCTION
END COMPONENT
# ---
# 模块 4: 收藏夹系统 (MOD-04)
# ---

## 4.1 目标
# - 提供一个灵活的系统来组织用户喜欢的漫画。
# - 支持多层级（文件夹式）的收藏夹结构。
# - 在应用各处（书架、阅读器）都能方便地管理收藏状态。
# - 允许以 JSON 格式导入/导出收藏夹数据。

## 4.2 收藏夹管理 BLoC 伪代码 (`favorites_bloc.dart`)

# -- Events --
ABSTRACT CLASS FavoritesEvent {}
CLASS LoadFavorites extends FavoritesEvent {}
CLASS CreateFavoriteFolder extends FavoritesEvent { name: STRING, parentId: INT? }
CLASS RenameFavoriteFolder extends FavoritesEvent { folderId: INT, newName: STRING }
CLASS DeleteFavoriteFolder extends FavoritesEvent { folderId: INT }
CLASS AddComicToFavorite extends FavoritesEvent { comicId: STRING, folderId: INT }
CLASS RemoveComicFromFavorite extends FavoritesEvent { comicId: STRING, folderId: INT }

# -- States --
ABSTRACT CLASS FavoritesState {}
CLASS FavoritesInitial extends FavoritesState {}
CLASS FavoritesLoading extends FavoritesState {}
CLASS FavoritesLoaded extends FavoritesState {
  # 使用树状结构来表示层级收藏夹
  favoriteTree: Node<Favorite> 
  # 也可以使用一个扁平列表和一个 Map 来快速查找
  # flatList: List<Favorite>
  # comicsByFolderId: Map<INT, List<Comic>>
}
CLASS FavoritesError extends FavoritesState { message: STRING }


# -- BLoC --
CLASS FavoritesBloc EXTENDS Bloc<FavoritesEvent, FavoritesState>:
  PRIVATE favoritesRepository: IFavoritesRepository # 假设有这个仓库

  CONSTRUCTOR(this.favoritesRepository):
    super(FavoritesInitial())
    on<LoadFavorites>(mapLoadFavoritesToState)
    # ... 其他事件处理器
  END CONSTRUCTOR

  FUNCTION mapLoadFavoritesToState(event, emit):
    emit(FavoritesLoading())
    result = await favoritesRepository.getFavoritesTree()
    result.fold(
      (failure) => emit(FavoritesError(failure.message)),
      (tree) => emit(FavoritesLoaded(favoriteTree: tree))
    )
  END FUNCTION
END CLASS

## 4.3 收藏夹管理界面伪代码 (`favorites_screen.dart`)

CLASS FavoritesScreen EXTENDS StatelessWidget:
  FUNCTION build(context):
    RETURN BlocProvider(
      create: (_) => di.sl<FavoritesBloc>()..add(LoadFavorites()),
      child: Scaffold(
        appBar: AppBar(title: Text("收藏夹")),
        body: BlocBuilder<FavoritesBloc, FavoritesState>(
          builder: (context, state) =>
            IF state IS FavoritesLoaded:
              # 渲染一个可展开/折叠的树状视图
              RETURN TreeView(
                data: state.favoriteTree,
                onFolderTap: (folderId) => # 导航到显示该文件夹下漫画的页面
                , 
                onFolderLongPress: (folder) => # 显示重命名/删除菜单
              )
            # ... 其他状态处理
        ),
        floatingActionButton: FloatingActionButton(
          onPressed: () => # 显示创建新收藏夹对话框
        )
      )
    )
  END FUNCTION
END CLASS

## 4.4 在其他界面切换收藏状态

# 切换收藏状态是一个常见的操作，可以通过一个专用的 UseCase 来处理。

CLASS ToggleFavoriteUseCase:
  PRIVATE comicRepository: IComicRepository

  FUNCTION call(comicId, isFavorite):
    await comicRepository.updateComicFavoriteStatus(comicId, isFavorite)
END CLASS

# **在书架界面:**
# 在 ComicGridItem 的上下文菜单中添加一个 "添加到收藏夹" 按钮。
# 点击后，可以显示一个对话框，让用户选择要添加到哪个收藏夹文件夹。

# **在阅读器界面 (`ReaderScreen`):**
# ReaderAppBar 中已有一个书签/收藏按钮。
# 点击该按钮时，可以触发一个事件，更新当前漫画的 isFavorite 状态。
COMPONENT FavoriteToggleButton in ReaderAppBar:
  FUNCTION build(context, comic):
    RETURN IconButton(
      icon: Icon(comic.isFavorite ? Icons.favorite : Icons.favorite_border),
      onPressed: () => {
        newStatus = !comic.isFavorite
        # 直接调用 UseCase 或通过 Bloc 发送事件
        di.sl<ToggleFavoriteUseCase>().call(comic.id, newStatus)
        # UI 可能需要等待 Bloc 状态更新或立即反馈
      }
    )
  END FUNCTION
END COMPONENT


## 4.5 收藏夹导入/导出

# 该功能可以集成到设置页面的备份/恢复功能中。
# 使用模块 2.4 中定义的 JSON 结构。

CLASS FavoritesImportExportService:
  PRIVATE favoritesRepository: IFavoritesRepository
  
  # 导出
  FUNCTION exportFavorites(): FUTURE<String>:
    favorites = await favoritesRepository.getAllFavorites()
    links = await favoritesRepository.getAllLinks()
    jsonData = {
      "favorites": favorites.map((f) => f.toJson()).toList(),
      "comicFavoriteLinks": links.map((l) => l.toJson()).toList()
    }
    RETURN jsonEncode(jsonData)
  END FUNCTION

  # 导入
  FUNCTION importFavorites(jsonString): FUTURE<VOID>:
    jsonData = jsonDecode(jsonString)
    # 清空现有收藏夹数据 (或提供合并选项)
    await favoritesRepository.clearAll()
    # 从 JSON 数据创建新的数据库条目
    await favoritesRepository.insertFavoritesFromJson(jsonData['favorites'])
    await favoritesRepository.insertLinksFromJson(jsonData['comicFavoriteLinks'])
  END FUNCTION
END CLASS
# ---
# 模块 5: 文件管理和导入 (MOD-05)
# ---

## 5.1 目标
# - 提供一个内置的文件浏览器，方便用户从设备存储中选择漫画文件。
# - 支持批量导入漫画文件到指定的书架。
# - 在导入前对文件格式进行有效性检查。
# - 提供基本的应用内文件管理功能。

## 5.2 文件导入服务伪代码 (`import_service.dart`)

# 这个服务将处理文件导入的复杂逻辑
CLASS ImportService:
  PRIVATE comicRepository: IComicRepository
  PRIVATE archiveService: IArchiveService # 用于解析和验证文件
  PRIVATE thumbnailService: IThumbnailService # 用于生成封面
  
  # 监听导入进度的流
  PROPERTY progressStream: Stream<ImportProgress>

  # 批量导入
  FUNCTION importComics(filePaths, bookshelfId):
    totalFiles = filePaths.length
    importedCount = 0
    
    FOR filePath in filePaths:
      emitProgress(importedCount, totalFiles, '正在检查 $filePath')
      
      # 1. 验证文件
      isValid = await archiveService.isValid(filePath)
      IF NOT isValid:
        logError('$filePath 不是有效的漫画文件')
        CONTINUE
      END IF

      # 2. 检查是否已存在
      isExisting = await comicRepository.comicExists(filePath)
      IF isExisting:
        logInfo('$filePath 已存在于书架中')
        CONTINUE
      END IF

      # 3. 解析元数据
      pageCount = await archiveService.getPageCount(filePath)
      
      # 4. 生成封面缩略图
      coverPath = await thumbnailService.createThumbnail(filePath)

      # 5. 创建漫画实体并存入数据库
      newComic = Comic(
        filePath: filePath,
        fileName: getFileName(filePath),
        coverPath: coverPath,
        pageCount: pageCount,
        bookshelfId: bookshelfId,
        # ... 其他默认值
      )
      await comicRepository.addComic(newComic)
      
      importedCount++
      emitProgress(importedCount, totalFiles, '成功导入 $filePath')
    END FOR
    
    emitProgress(importedCount, totalFiles, '导入完成')
  END FUNCTION

  PRIVATE FUNCTION emitProgress(count, total, message):
    # 将进度更新推送到 progressStream
  END FUNCTION
END CLASS

## 5.3 文件浏览器 UI 伪代码 (`file_browser_screen.dart`)

# 这个页面可以使用一个现有的包，如 `file_picker`，或者自定义实现。
CLASS FileBrowserScreen EXTENDS StatelessWidget:
  # ...
  FUNCTION build(context):
    RETURN Scaffold(
      appBar: AppBar(
        title: Text("选择文件"),
        actions: [
          # 允许多选
          IconButton(icon: Icon(Icons.check_box), onPressed: () => toggleMultiSelect()),
        ]
      ),
      body: # 渲染文件和文件夹列表
        # ...
        # 用户选择文件后，调用 Navigator.pop(selectedFilePaths)
      ,
      floatingActionButton: FloatingActionButton(
        child: Icon(Icons.check),
        onPressed: () => {
          # 返回选中的文件路径
          Navigator.pop(context, getSelectedFiles())
        }
      )
    )
  END FUNCTION
END CLASS

## 5.4 导入流程集成

# 在 `HomeScreen` 的 FloatingActionButton 的 `onPressed` 事件中：
FUNCTION onImportButtonPressed(context):
  # 1. 导航到文件浏览器
  selectedFiles = await Navigator.push(context, MaterialPageRoute(builder: (_) => FileBrowserScreen()))
  
  IF selectedFiles IS NOT NULL AND selectedFiles isNotEmpty:
    # 2. (可选) 显示对话框，让用户选择要导入到的书架
    selectedBookshelfId = await showSelectBookshelfDialog(context)

    # 3. 显示导入进度 UI
    showImportProgressIndicator(context)

    # 4. 开始导入过程
    importService = di.sl<ImportService>()
    # 可以在这里监听 importService.progressStream 来更新 UI
    await importService.importComics(selectedFiles, selectedBookshelfId)

    # 5. 导入完成后，刷新书架
    context.read<HomeBloc>().add(LoadBookshelf(selectedBookshelfId))
  END IF
END FUNCTION

## 5.5 应用内文件管理

# 文件管理（重命名/移动）是复杂且有风险的操作，尤其是在 Android 的分区存储下。
# 初期可以简化为只管理数据库中的条目，而不是直接操作文件系统。

# **重命名漫画条目:**
# 在 `ComicGridItem` 的上下文菜单中添加 "重命名" 选项。
FUNCTION renameComic(comicId, newName):
  # 这只更新数据库中的 `fileName`，不改变实际文件名
  await comicRepository.updateComicFileName(comicId, newName)
END FUNCTION

# **移动漫画到不同书架:**
# 在 `ComicGridItem` 的上下文菜单中添加 "移动到..." 选项。
FUNCTION moveComic(comicId, newBookshelfId):
  await comicRepository.updateComicBookshelf(comicId, newBookshelfId)
END FUNCTION
# ---
# 模块 6: WebDAV 备份 (MOD-06)
# ---

## 6.1 目标
# - 通过 WebDAV 协议实现应用数据的云端备份和恢复。
# - 支持自动和手动同步。
# - 提供简单的冲突解决机制。
# - 在设置中提供清晰的 WebDAV 配置界面。

## 6.2 WebDAV 服务伪代码 (`webdav_service.dart`)

CLASS WebDavService:
  PRIVATE webdavClient: WebDavClient
  PRIVATE settingsService: ISettingsService
  PRIVATE backupService: IBackupService # 负责生成和解析备份 JSON

  FUNCTION configureClient():
    config = await settingsService.getWebDavConfig()
    IF config IS NOT NULL:
      webdavClient.setClient(
        uri: config.uri,
        user: config.user,
        password: config.password
      )
    END IF
  END FUNCTION

  FUNCTION testConnection(): FUTURE<Either<Failure, Success>>:
    TRY
      await webdavClient.ping()
      RETURN Right(Success())
    CATCH e:
      RETURN Left(ConnectionFailure(e.toString()))
    END TRY
  END FUNCTION

  FUNCTION backupData(): FUTURE<Either<Failure, Success>>:
    # 1. 生成备份数据
    jsonData = await backupService.createBackupJson()
    
    # 2. 上传到 WebDAV
    remotePath = '/EasyComic/backup.json'
    TRY
      await webdavClient.write(remotePath, jsonData.toBytes())
      # (可选) 上传一个时间戳文件以进行增量同步检查
      await webdavClient.write('/EasyComic/last_sync.txt', DateTime.now().toIso8601String().toBytes())
      RETURN Right(Success())
    CATCH e:
      RETURN Left(UploadFailure(e.toString()))
    END TRY
  END FUNCTION

  FUNCTION restoreData(): FUTURE<Either<Failure, ServerDataInfo>>:
    # 1. 从服务器获取备份文件
    remotePath = '/EasyComic/backup.json'
    TRY
      bytes = await webdavClient.read(remotePath)
      jsonData = DART_UTF8.decode(bytes) # 假设是 UTF8
      
      # 2. 解析服务器数据以进行预览或冲突检查
      serverInfo = backupService.getBackupInfo(jsonData)
      RETURN Right(serverInfo) # 返回服务器数据信息供用户确认
    CATCH e:
      RETURN Left(DownloadFailure(e.toString()))
    END TRY
  END FUNCTION

  FUNCTION applyRestore(jsonData):
    await backupService.restoreFromBackupJson(jsonData)
  END FUNCTION

END CLASS

## 6.3 同步 BLoC/服务 (`sync_bloc.dart`)

# 可以创建一个 BLoC 来管理同步界面的状态

# -- Events --
ABSTRACT CLASS SyncEvent {}
CLASS CheckWebDavConnection extends SyncEvent {}
CLASS StartBackup extends SyncEvent {}
CLASS StartRestore extends SyncEvent {}
CLASS AutoSyncToggled extends SyncEvent { isEnabled: BOOLEAN }

# -- States --
ABSTRACT CLASS SyncState {}
CLASS SyncInitial extends SyncState { webdavConfig: WebDavConfig?, isAutoSyncEnabled: BOOLEAN }
CLASS SyncInProgress extends SyncState { message: STRING }
CLASS SyncSuccess extends SyncState { message: STRING, lastSyncTime: DATETIME }
CLASS SyncError extends SyncState { message: STRING }
CLASS RestoreReady extends SyncState { serverDataInfo: ServerDataInfo }

# -- BLoC --
CLASS SyncBloc EXTENDS Bloc<SyncEvent, SyncState>:
  # ... 依赖 WebDavService
  # ... 事件处理逻辑
END CLASS


## 6.4 WebDAV 配置界面伪代码 (`webdav_settings_screen.dart`)

CLASS WebDavSettingsScreen EXTENDS StatelessWidget:
  # ... Form controllers for URI, user, password
  
  FUNCTION build(context):
    RETURN Scaffold(
      appBar: AppBar(title: Text("WebDAV 设置")),
      body: BlocConsumer<SyncBloc, SyncState>(
        listener: (context, state) => {
          # 显示 SnackBar 通知成功或失败
        },
        builder: (context, state) =>
          Form(
            # ... 输入字段
            ElevatedButton(
              onPressed: () => context.read<SyncBloc>().add(CheckWebDavConnection()),
              child: Text("测试连接")
            ),
            ElevatedButton(
              onPressed: () => context.read<SyncBloc>().add(StartBackup()),
              child: Text("立即备份")
            ),
            ElevatedButton(
              onPressed: () => context.read<SyncBloc>().add(StartRestore()),
              child: Text("恢复数据")
            ),
            SwitchListTile(
              title: Text("自动同步"),
              value: state.isAutoSyncEnabled,
              onChanged: (value) => context.read<SyncBloc>().add(AutoSyncToggled(isEnabled: value)),
            )
          )
      )
    )
  END FUNCTION
END CLASS

## 6.5 冲突解决与增量同步

# **冲突解决 (简单策略):**
# 在恢复数据之前，向用户显示本地数据和服务器数据的基本信息（如备份日期、漫画数量）。
# 提供选项:
# 1. **覆盖本地数据**: 用服务器数据完全替换本地数据。
# 2. **合并数据 (高级)**: 需要复杂的逻辑，初期不实现。首先只提供覆盖选项。
# 3. **取消**: 不执行任何操作。

# **增量同步 (概念):**
# 真正的增量同步很复杂。一个简化的方法是 "基于时间戳的智能备份"。
# 1. 每次备份时，在服务器上记录一个 `last_sync.txt` 文件。
# 2. 在自动备份前，检查本地数据库中是否有在 `last_sync.txt` 时间戳之后被修改过的条目。
# 3. 如果有，则执行完整备份。如果没有，则跳过本次自动备份。
# 这不是真正的增量同步，但可以减少不必要的上传。
# ---
# 模块 7: UI 增强 (MOD-07)
# ---

## 7.1 目标
# - 修复和完善应用的核心导航元素（导航栏、底部标签栏）。
# - 提供一个功能完整且易于使用的设置页面。
# - 实现流畅的亮/暗模式主题切换。
# - 在耗时操作期间提供明确的用户反馈（加载指示器）。

## 7.2 主导航 (`main_navigation.dart` or part of `home_screen.dart`)

# 应用的主导航可以使用 BottomNavigationBar 来切换不同的顶级页面。
CLASS MainNavigationScreen EXTENDS StatefulWidget:
  STATE:
    currentIndex = 0
    pages = [BookshelfScreen(), FavoritesScreen(), SettingsScreen()]
    
  FUNCTION build(context):
    RETURN Scaffold(
      body: IndexedStack(
        index: currentIndex,
        children: pages
      ),
      bottomNavigationBar: BottomNavigationBar(
        currentIndex: currentIndex,
        onTap: (index) => setState(() => currentIndex = index),
        items: [
          BottomNavigationBarItem(icon: Icon(Icons.book), label: '书架'),
          BottomNavigationBarItem(icon: Icon(Icons.favorite), label: '收藏'),
          BottomNavigationBarItem(icon: Icon(Icons.settings), label: '设置'),
        ]
      )
    )
  END FUNCTION
END CLASS

# `AppRouter` 中的 `home` 路由应指向这个 `MainNavigationScreen`。

## 7.3 设置页面 (`settings_screen.dart`)

# 设置页面应该清晰地分类，并允许用户修改应用行为。
CLASS SettingsScreen EXTENDS StatelessWidget:
  FUNCTION build(context):
    RETURN Scaffold(
      appBar: AppBar(title: Text("设置")),
      body: ListView(
        children: [
          # -- 外观 --
          SettingsCategory(title: "外观"),
          ThemeSwitchTile(),
          # ... 其他外观设置
          
          # -- 阅读 --
          SettingsCategory(title: "阅读"),
          ReadingDirectionTile(),
          AutoPageIntervalSlider(),
          # ... 其他阅读设置

          # -- 同步 --
          SettingsCategory(title: "同步"),
          ListTile(
            title: Text("WebDAV 同步"),
            onTap: () => Navigator.push(context, WebDavSettingsScreen())
          ),

          # -- 关于 --
          SettingsCategory(title: "关于"),
          ListTile(title: Text("版本"), subtitle: Text("1.0.0")),
        ]
      )
    )
  END FUNCTION
END CLASS

## 7.4 主题切换 (`theme_bloc.dart`)

# ThemeBloc 负责管理应用的主题状态。
# -- Events --
CLASS LoadTheme extends ThemeEvent {}
CLASS ThemeChanged extends ThemeEvent { themeMode: ThemeMode }

# -- States --
CLASS ThemeState {
  themeMode: ThemeMode
  lightTheme: ThemeData
  darkTheme: ThemeData
}

# `App.dart` 中已经包含了 BlocProvider 和对 ThemeState 的响应。
# 在 `SettingsScreen` 中:
COMPONENT ThemeSwitchTile:
  FUNCTION build(context):
    RETURN BlocBuilder<ThemeBloc, ThemeState>(
      builder: (context, state) =>
        SwitchListTile(
          title: Text("暗色模式"),
          value: state.themeMode == ThemeMode.dark,
          onChanged: (isDark) => {
            newMode = isDark ? ThemeMode.dark : ThemeMode.light
            context.read<ThemeBloc>().add(ThemeChanged(themeMode: newMode))
          }
        )
    )
  END FUNCTION
END COMPONENT

## 7.5 全局进度指示器和提示

# 可以创建一个全局服务或使用一个顶层 widget 来显示加载提示。
# 一个简单的方法是创建一个可重用的 `showLoadingDialog` 函数。

FUNCTION showLoadingDialog(context, message):
  showDialog(
    context: context,
    barrierDismissible: false, # 用户不能通过点击外部来关闭
    builder: (_) => AlertDialog(
      content: Row(
        children: [
          CircularProgressIndicator(),
          SizedBox(width: 16),
          Text(message)
        ]
      )
    )
  )
END FUNCTION

# 在 BLoC 的 `listener` 中使用这个函数:
# BlocListener<MyBloc, MyState>(
#   listener: (context, state) {
#     if (state is MyLoading) {
#       showLoadingDialog(context, "请稍候...");
#     } else if (state is MySuccess || state is MyError) {
#       Navigator.of(context).pop(); // 关闭对话框
#     }
#   },
#   child: ...
# )
# ---
# 模块 8: 错误处理和调试 (MOD-08)
# ---

## 8.1 目标
# - 建立一个全局的异常捕获机制，防止应用崩溃。
# - 实现一个可配置的日志系统，用于调试和问题追踪。
# - 在执行网络操作前，主动检测网络连接状态。

## 8.2 全局异常捕获

# 在 `main.dart` 中设置全局捕获。
FUNCTION setupGlobalErrorHandler():
  # 捕获 Flutter 框架内的错误
  FlutterError.onError = (details) => {
    logError("Flutter Error: ${details.exception}", details.stack)
    # 可以在这里上报到 Firebase Crashlytics 或 Sentry
  }
  
  # 捕获 Dart isolate 中的错误
  PlatformDispatcher.instance.onError = (error, stack) => {
    logError("Platform Error: $error", stack)
    RETURN true # 表示错误已处理
  }
END FUNCTION

## 8.3 日志系统 (`logging_service.dart`)

# 可以使用一个现成的日志包，如 `logger`。
# 以下是日志服务的抽象概念。

enum LogLevel { Verbose, Debug, Info, Warning, Error }

INTERFACE ILoggingService:
  FUNCTION setLogLevel(level)
  FUNCTION v(message) # Verbose
  FUNCTION d(message) # Debug
  FUNCTION i(message) # Info
  FUNCTION w(message, [error, stackTrace]) # Warning
  FUNCTION e(message, [error, stackTrace]) # Error
END INTERFACE

CLASS LoggingServiceImpl IMPLEMENTS ILoggingService:
  PRIVATE logger: Logger # 例如，来自 'logger' 包的实例
  
  # ... 实现接口 ...
  
  FUNCTION e(message, [error, stackTrace]):
    logger.e(message, error: error, stackTrace: stackTrace)
    # 在这里可以添加逻辑，将错误日志写入文件或发送到远程服务器
  END FUNCTION
END CLASS

# **在代码中使用日志:**
# final log = di.sl<ILoggingService>();
# log.i("用户已登录");
#
# CATCH (e, s) {
#   log.e("数据加载失败", error: e, stackTrace: s);
#   emit(DataErrorState("无法加载数据"));
# }

## 8.4 网络状态检测

# 可以使用 `connectivity_plus` 包来检测网络状态。
# 最好是创建一个 `NetworkInfo` 服务。

INTERFACE INetworkInfo:
  FUTURE<bool> get isConnected
END INTERFACE

CLASS NetworkInfoImpl IMPLEMENTS INetworkInfo:
  PRIVATE connectivity: Connectivity
  
  CONSTRUCTOR(this.connectivity)
  
  FUTURE<bool> get isConnected:
    result = await connectivity.checkConnectivity()
    RETURN result != ConnectivityResult.none
  END FUNCTION
END CLASS

# **在执行网络操作前检查:**
CLASS WebDavService:
  PRIVATE networkInfo: INetworkInfo
  
  FUNCTION backupData():
    IF await networkInfo.isConnected:
      # ... 执行上传
    ELSE:
      RETURN Left(NetworkFailure("无网络连接"))
    END IF
  END FUNCTION
END CLASS

## 8.5 UI 层的错误显示

# BLoC 的 `State` 应该包含一个 `Failure` 或 `errorMessage` 字段。
# UI 组件使用 `BlocBuilder` 或 `BlocListener` 来响应错误状态。

# **示例: 书架页面**
# BlocBuilder<HomeBloc, HomeState>(
#   builder: (context, state) => {
#     if (state is HomeError) {
#       return Center(
#         child: Column(
#           children: [
#             Icon(Icons.error_outline),
#             Text(state.message),
#             ElevatedButton(
#               onPressed: () => context.read<HomeBloc>().add(RetryLoad()),
#               child: Text("重试")
#             )
#           ]
#         )
#       )
#     }
#     // ... 其他状态的 UI
#   }
# )
# ---
# 模块 9: 性能优化 (MOD-09)
# ---

## 9.1 目标
# - 确保应用在处理大量漫画和图片时保持流畅和响应迅速。
# - 有效管理内存和存储，避免内存泄漏和不必要的磁盘占用。
# - 优化数据库交互，减少查询延迟。

## 9.2 图像缓存管理 (`cache_service.dart`)

# 遵循 `systemPatterns.md` 中定义的多级缓存策略。
# `CacheService` 已经在 `injection_container` 中注册。
# 这里重申其核心逻辑。

CLASS CacheService IMPLEMENTS ICacheService:
  PRIVATE memoryCache: LruMap<String, MemoryImage> # LRU 内存缓存
  PRIVATE diskCacheManager: DiskCacheManager # 磁盘缓存管理器
  
  FUNCTION getImage(url):
    # 1. 检查内存缓存
    IF memoryCache.containsKey(url):
      RETURN memoryCache.get(url)
    END IF
    
    # 2. 检查磁盘缓存
    diskImage = await diskCacheManager.getImage(url)
    IF diskImage IS NOT NULL:
      # 将磁盘图片加载到内存并返回
      memoryImage = decodeImage(diskImage)
      memoryCache.put(url, memoryImage)
      RETURN memoryImage
    END IF
    
    # 3. 如果都没有，则从源加载 (在阅读器中是从文件解压)
    # newImage = await loadFromSource(url)
    # cacheInMemory(url, newImage)
    # cacheOnDisk(url, newImage)
    # RETURN newImage
    
  END FUNCTION

  # -- 内存压力管理 --
  # 在 `main.dart` 中监听内存压力，并在收到警告时主动清理缓存。
  FUNCTION onMemoryPressureWarning():
    log.w("收到内存压力警告，清理缓存...")
    memoryCache.clear()
    # 可以根据压力级别选择不同的清理策略
  END FUNCTION
END CLASS

## 9.3 数据库查询优化

# 数据库 (Drift) 查询优化主要通过以下方式实现:
# 1. **建立索引**: 在 `Comics` 表的 `bookshelfId` 和 `lastReadTime` 字段上建立索引，以加快书架加载和历史记录查询。
#    - 在 TABLE 定义中使用 `@DriftIndex` 注解。
# 2. **分页查询**: 当书架漫画非常多时，不一次性加载所有条目。
#    - `ComicRepository` 的 `getComics` 方法应支持分页参数 (limit, offset)。
#    - UI 层使用无限滚动列表，在滚动到底部时加载下一页。
# 3. **使用 Stream**: Drift 支持响应式查询。返回 `Stream` 而不是 `Future`。当数据变化时，UI 会自动更新。
#    - `ComicRepository.watchComics(bookshelfId)`
# 4. **避免 N+1 查询**: 当需要加载漫画及其关联数据（如标签）时，使用 `JOIN` 查询一次性获取所有数据，而不是循环查询。

# **分页查询示例:**
FUNCTION getComics(bookshelfId, limit, offset):
  query = (SELECT * FROM comics WHERE bookshelfId = ? LIMIT ? OFFSET ?)
  RETURN await db.executeQuery(query, [bookshelfId, limit, offset])
END FUNCTION

# **响应式查询示例:**
FUNCTION watchComics(bookshelfId):
  query = (SELECT * FROM comics WHERE bookshelfId = ?)
  RETURN db.watchQuery(query, [bookshelfId]) # 返回一个 Stream
END FUNCTION

## 9.4 优化大量文件加载

# **问题**: `PageView` 在默认情况下会构建视口之外的几个页面，如果每个页面都很大，会消耗大量内存。
# **策略**:
# 1. **使用 `PageView.builder`**: 这是必须的，它只在需要时构建页面。
# 2. **预加载策略**: 在 `ReaderBloc` 中，维护一个预加载队列。
   # - 当前页面: P
   # - 高优先级预加载: P+1, P-1
   # - 低优先级预加载: P+2, P+3
# 3. **图片解码和尺寸调整**:
   # - 不直接加载原始图片，而是根据屏幕尺寸解码为适当大小的 `ui.Image`。
   # - Flutter 的 `decodeImageFromList` 方法可以指定目标宽度/高度。
   # - 这可以显著降低单张图片的内存占用。
# 4. **内存回收**: 当页面滑出预加载范围时（例如，从 P 滑到 P+5），主动释放 P-1, P-2 页面的内存缓存。

# **ReaderBloc 中的预加载逻辑:**
FUNCTION onPageChanged(event, emit):
  currentPage = event.pageIndex
  # ... 更新状态 ...
  
  # 触发预加载
  preloadingService.updatePriority(
    high: [currentPage+1, currentPage-1],
    low: [currentPage+2, currentPage+3]
  )
  
  # 触发内存回收
  cacheService.releaseImagesOutsideRange(currentPage-3, currentPage+4)
END FUNCTION